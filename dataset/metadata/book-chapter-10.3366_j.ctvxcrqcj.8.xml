

<book xmlns:oasis="http://docs.oasis-open.org/ns/oasis-exchange/table"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:mml="http://www.w3.org/1998/Math/MathML"
      dtd-version="0.2"
      xml:lang="eng">
   <collection-meta>
      <collection-id collection-id-type="jstor">j.ctvxbpft1</collection-id>
   </collection-meta>
   <book-meta>
      <book-id book-id-type="doi">10.3366/j.ctvxcrqcj</book-id>
      <subj-group subj-group-type="discipline">
         <subject>Computer Science</subject>
      </subj-group>
      <book-title-group>
         <book-title>Programming for Corpus Linguistics</book-title>
         <subtitle>How to Do Text Analysis with Java</subtitle>
      </book-title-group>
      <contrib-group>
         <role content-type="editor">Series Editors:</role>
         <contrib contrib-type="editor" id="contrib1">
            <name name-style="western">
               <surname>McEnery</surname>
               <given-names>Tony</given-names>
            </name>
         </contrib>
         <contrib contrib-type="editor" id="contrib2">
            <name name-style="western">
               <surname>Wilson</surname>
               <given-names>Andrew</given-names>
            </name>
         </contrib>
      </contrib-group>
      <contrib-group>
         <contrib contrib-type="author" id="contrib3">
            <name name-style="western">
               <surname>Mason</surname>
               <given-names>Oliver</given-names>
            </name>
         </contrib>
      </contrib-group>
      <pub-date>
         <day>20</day>
         <month>12</month>
         <year>2000</year>
      </pub-date>
      <isbn content-type="ppub">9780748614073</isbn>
      <isbn content-type="epub">9781474470780</isbn>
      <publisher>
         <publisher-name>Edinburgh University Press</publisher-name>
         <publisher-loc>Edinburgh</publisher-loc>
      </publisher>
      <permissions>
         <copyright-year>2000</copyright-year>
         <copyright-holder>Oliver Mason</copyright-holder>
      </permissions>
      <self-uri xlink:href="https://www.jstor.org/stable/10.3366/j.ctvxcrqcj"/>
      <abstract abstract-type="short">
         <p>This book enables the researcher to write programs for text and corpus processing for linguistics. Useful techniques are illustrated with the popular programming language Java, which is very well suited for handling textual data, and at the same time easy to learn.</p>
      </abstract>
      <counts>
         <page-count count="256"/>
      </counts>
      <custom-meta-group>
         <custom-meta>
            <meta-name>
                    lang
                </meta-name>
            <meta-value>eng</meta-value>
         </custom-meta>
      </custom-meta-group>
   </book-meta>
   <body>
      <book-part indexed="true" xlink:type="simple">
         <body>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="doi">10.3366/j.ctvxcrqcj.1</book-part-id>
                  <title-group>
                     <title>Front Matter</title>
                  </title-group>
                  <fpage>[i]</fpage>
               </book-part-meta>
            </book-part>
         </body>
      </book-part>
      <book-part indexed="true" xlink:type="simple">
         <body>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="doi">10.3366/j.ctvxcrqcj.2</book-part-id>
                  <title-group>
                     <title>Table of Contents</title>
                  </title-group>
                  <fpage>[v]</fpage>
               </book-part-meta>
            </book-part>
         </body>
      </book-part>
      <book-part indexed="true" xlink:type="simple">
         <body>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="doi">10.3366/j.ctvxcrqcj.3</book-part-id>
                  <title-group>
                     <label>1</label>
                     <title>Introduction</title>
                  </title-group>
                  <fpage>3</fpage>
                  <abstract>
                     <p>Corpus linguistics is all about analysing language data in order to draw conclusions about how language works. To make valid claims about the nature of language, one usually has to look at large numbers of words, often more than one million. Such amounts of text are clearly outside the scope of manual analysis, and so we need the help of computers. But the computer, powerful though it is, is not an easy tool to use for someone with a humanities background, and so its use is generally restricted to whatever ready-made programs are available at the moment.</p>
                     <p>This book is</p>
                  </abstract>
               </book-part-meta>
            </book-part>
         </body>
      </book-part>
      <book-part indexed="true" xlink:type="simple">
         <body>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="doi">10.3366/j.ctvxcrqcj.4</book-part-id>
                  <title-group>
                     <label>2</label>
                     <title>Introduction to Basic Programming Concepts</title>
                  </title-group>
                  <fpage>13</fpage>
                  <abstract>
                     <p>This section is for beginners who have not done any programming yet. It briefly introduces the algorithm, a general form of a computer program, and ways to express tasks in algorithmic form. Plenty of examples from non-programming domains are used to make it accessible to newcomers.</p>
                     <p>A computer program is simply a list of instructions which the machine executes in the specified order. These instructions have to be in a code that the machine can interpret in some way, which is roughly what a computer language is. In order to make it easier for humans to write programs, special programming</p>
                  </abstract>
               </book-part-meta>
            </book-part>
         </body>
      </book-part>
      <book-part indexed="true" xlink:type="simple">
         <body>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="doi">10.3366/j.ctvxcrqcj.5</book-part-id>
                  <title-group>
                     <label>3</label>
                     <title>Basic Corpus Concepts</title>
                  </title-group>
                  <fpage>31</fpage>
                  <abstract>
                     <p>This chapter introduces relevant concepts from corpus linguistics. It is intended as a brief introduction to enable you to understand the principal problems that you will encounter when working with corpora.</p>
                     <p>Unless you are working with a research group that already has a set of corpora available that you want to analyse, your first question will be where to get data from and how to assemble it to a corpus. For the remainder of this section we will assume that you want to build your own corpus for analysis. There are several reasons why you might want to do this.</p>
                  </abstract>
               </book-part-meta>
            </book-part>
         </body>
      </book-part>
      <book-part indexed="true" xlink:type="simple">
         <body>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="doi">10.3366/j.ctvxcrqcj.6</book-part-id>
                  <title-group>
                     <label>4</label>
                     <title>Basic Java Programming</title>
                  </title-group>
                  <fpage>47</fpage>
                  <abstract>
                     <p>Before we can start writing programs in Java we will need to cover some more ground: the basics of object-oriented programming. We have already heard that Java is an object-oriented programming language, and now we are going to see what that means for writing programs in it.</p>
                     <p>Object-oriented programming, or OOP, was developed in order to make it easier to design robust and maintainable software. It basically tries to provide an easy to understand structure or model for the software developer by reducing the overall complexity of a program through splitting it into autonomous components, or objects.</p>
                     <p>OOP is a</p>
                  </abstract>
               </book-part-meta>
            </book-part>
         </body>
      </book-part>
      <book-part indexed="true" xlink:type="simple">
         <body>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="doi">10.3366/j.ctvxcrqcj.7</book-part-id>
                  <title-group>
                     <label>5</label>
                     <title>The Java Class Library</title>
                  </title-group>
                  <fpage>61</fpage>
                  <abstract>
                     <p>In this chapter we will first briefly cover the way different parts of the Java class library are organised. Related classes are arranged in so-called packages , and understanding the mechanics of those is fundamental for Java programming. After that we will have a brief look at how Java deals with errors, before we then look in detail at one of the most important classes of the Java language, the String class, which is used to represent sequences of characters. We’ll investigate the API of the String class, with examples of how the individual methods it provides can be used.</p>
                  </abstract>
               </book-part-meta>
            </book-part>
         </body>
      </book-part>
      <book-part indexed="true" xlink:type="simple">
         <body>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="doi">10.3366/j.ctvxcrqcj.8</book-part-id>
                  <title-group>
                     <label>6</label>
                     <title>Input/Output</title>
                  </title-group>
                  <fpage>97</fpage>
                  <abstract>
                     <p>Input and Output (I/O) is essentially what data processing is all about. The basic procedure is that data is read in from a file or other external source, then processed in core memory, and the result of the processing sent either to the screen or into another file. The input could for example be a text file containing a corpus, and the output file could be a list of all words ordered by frequency of occurrence. This chapter describes how to do this. At first we will have a look at the Java I/O architecture, and how we can extend</p>
                  </abstract>
               </book-part-meta>
            </book-part>
         </body>
      </book-part>
      <book-part indexed="true" xlink:type="simple">
         <body>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="doi">10.3366/j.ctvxcrqcj.9</book-part-id>
                  <title-group>
                     <label>7</label>
                     <title>Processing Plain Text</title>
                  </title-group>
                  <fpage>133</fpage>
                  <abstract>
                     <p>There are plenty of different shapes or forms that text can come in, mainly due to sophisticated word processing or desktop publishing programs that combine layout information and images with text itself. As we discussed in chapter 3, one could try and reverse-engineer these formats, but that is often a very difficult task that requires a lot of expertise with data formats, so if you want to use such texts for your corpus work you would face quite a problem before you even got started. You will probably be best off trying to convert any such data into plain text</p>
                  </abstract>
               </book-part-meta>
            </book-part>
         </body>
      </book-part>
      <book-part indexed="true" xlink:type="simple">
         <body>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="doi">10.3366/j.ctvxcrqcj.10</book-part-id>
                  <title-group>
                     <label>8</label>
                     <title>Dealing with Annotations</title>
                  </title-group>
                  <fpage>153</fpage>
                  <abstract>
                     <p>In chapter 3 we discussed the background of annotations, and we mentioned there that XML should be used as the format for marking up your data, as it is becoming a standard. In this chapter we will first look at XML in a bit more detail, and then we will see how we can process it. Without the right software tools at hand it is rather awkward, but once you have cracked this, you will quickly see how powerful XML mark-up can be.</p>
                     <p>We will stick to a subset of XML, as its full specification is still changing. However, the</p>
                  </abstract>
               </book-part-meta>
            </book-part>
         </body>
      </book-part>
      <book-part indexed="true" xlink:type="simple">
         <body>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="doi">10.3366/j.ctvxcrqcj.11</book-part-id>
                  <title-group>
                     <label>9</label>
                     <title>Stemming</title>
                  </title-group>
                  <fpage>179</fpage>
                  <abstract>
                     <p>In this section we take a look at implementing a stemmer as described in Oakes (1998). Starting from a brief description we will see what it takes to turn a table of production rules into a working program.</p>
                     <p>Table 3.10 of Oakes (1998) lists a set of rules used by Paice (1977) for implementing a stemmer. A stemmer is a program that reduces word forms to a canonical form, almost like a lemmatiser. The main difference is that a lemmatiser will only take inflectional endings off a word, effectively resulting in a verb’s infinitive or the singular form of a</p>
                  </abstract>
               </book-part-meta>
            </book-part>
         </body>
      </book-part>
      <book-part indexed="true" xlink:type="simple">
         <body>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="doi">10.3366/j.ctvxcrqcj.12</book-part-id>
                  <title-group>
                     <label>10</label>
                     <title>Part of Speech Tagging</title>
                  </title-group>
                  <fpage>195</fpage>
                  <abstract>
                     <p>In a study question in McEnery and Wilson (1996) a simple part-of-speech tagger is described, and the task for the reader is to manually tag a sentence using the algorithm. In this chapter we will see what it takes to implement this as a computer program, as tagging is rather boring if it is done by hand. Before we look at the program itself there is a brief introduction to some relevant concepts of tagging.</p>
                     <p>Part-of-speech tagging is the process of assigning word class labels to tokens in a running text. The aim of this is to achieve a more</p>
                  </abstract>
               </book-part-meta>
            </book-part>
         </body>
      </book-part>
      <book-part indexed="true" xlink:type="simple">
         <body>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="doi">10.3366/j.ctvxcrqcj.13</book-part-id>
                  <title-group>
                     <label>11</label>
                     <title>Collocation Analysis</title>
                  </title-group>
                  <fpage>213</fpage>
                  <abstract>
                     <p>This chapter shows how to implement the facilities described in Language and Computers , chapter 5. There, Barnbrook describes in detail how to compute collocations.</p>
                     <p>Collocational analysis attempts to identify words that occur together significantly more often than one would expect by pure chance. These word pairs then form what is called a collocation. Collocations can be the result of a number of different underlying linguistic processes which influence the combinatory arrangement of words; these processes can be syntactic, semantic, or even prosodic. The way one can identify collocations is by looking at the frequency of words in the environment</p>
                  </abstract>
               </book-part-meta>
            </book-part>
         </body>
      </book-part>
      <book-part indexed="true" xlink:type="simple">
         <body>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="doi">10.3366/j.ctvxcrqcj.14</book-part-id>
                  <title-group>
                     <label>12</label>
                     <title>Appendix</title>
                  </title-group>
                  <fpage>231</fpage>
               </book-part-meta>
            </book-part>
         </body>
      </book-part>
      <book-part indexed="true" xlink:type="simple">
         <body>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="doi">10.3366/j.ctvxcrqcj.15</book-part-id>
                  <title-group>
                     <title>Index</title>
                  </title-group>
                  <fpage>237</fpage>
               </book-part-meta>
            </book-part>
         </body>
      </book-part>
   </body>
</book>
